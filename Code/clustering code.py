# -*- coding: utf-8 -*-
"""“2324project_partB.ipynb”的副本

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N-aEg2oGskkDXcK9IWGJ-JKsvQz7TDUh

# **1. Population Density**
"""

import json
import pandas as pd
from IPython.display import display

# Load JSON data
with open('Density_2022.json') as f:
    data = json.load(f)

# Extract and process features
table_data = []
for feature in data['features']:
    props = feature['properties']
    table_data.append({
        'District Code': props['DC'],
        'District Name (Chinese)': props['DC_CHI'],
        'District Name (English)': props['DC_ENG'],
        'Area (km²)': props['LA'],
        'Population (thousands)': props['MYPOPN_LAND'],
        'Year': props['PERIOD'],
        'Population Density': props['POPN_D']  # Keep as number for styling
    })

# Create DataFrame
df = pd.DataFrame(table_data)

# Create display copy with formatted strings
display_df = df.copy()
display_df['Area (km²)'] = display_df['Area (km²)'].map('{:.2f}'.format)
display_df['Population (thousands)'] = display_df['Population (thousands)'].map('{:.1f}'.format)
display_df['Population Density'] = display_df['Population Density'].map('{:,}'.format)

# Apply styling to the original numerical data
styled = (df.style
          .format({
              'Area (km²)': '{:.2f}',
              'Population (thousands)': '{:.1f}',
              'Population Density': '{:,}'
          })
          .background_gradient(
              cmap='Blues',
              subset=['Population Density'],
              vmin=df['Population Density'].min(),
              vmax=df['Population Density'].max()
          )
          .set_caption('Hong Kong District Population Statistics (2022)')
          .set_properties(**{'text-align': 'center'}))

# Display the styled table
display(styled)

!pip install geopandas folium

import geopandas as gpd
import folium
import pandas as pd

# Load GeoJSON data (Hong Kong district boundaries)
geo_data = gpd.read_file('Density_2022.json')

# Load population density data (already in df)
# Ensure 'District Code' matches the GeoJSON file's district code
geo_data = geo_data.merge(df, left_on='DC', right_on='District Code')

# Create a base map centered on Hong Kong
hong_kong_map = folium.Map(location=[22.3193, 114.1694], zoom_start=11)

# Add choropleth layer for population density
folium.Choropleth(
    geo_data=geo_data,
    data=geo_data,
    columns=['District Code', 'Population Density'],
    key_on='feature.properties.DC',
    fill_color='YlGnBu',
    fill_opacity=0.7,
    line_opacity=0.2,
    legend_name='Population Density (people/km²)',
    highlight=True
).add_to(hong_kong_map)

# Add district names directly to the map
for _, row in geo_data.iterrows():
    if row['geometry'].is_empty:
        continue

    centroid = row['geometry'].centroid
    folium.map.Marker(
        location=[centroid.y, centroid.x],
        icon=folium.DivIcon(
            html=f"""
            <div style="font-size: 10pt; font-weight: bold; color: black;
                     text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;">
                {row['District Name (English)']}<br>
                <span style="font-size: 8pt;">{row['District Name (Chinese)']}</span>
            </div>
            """
        )
    ).add_to(hong_kong_map)

style_function = lambda x: {'fillColor': '#ffffff', 'color':'#000000', 'fillOpacity': 0.1, 'weight': 0.1}
highlight_function = lambda x: {'fillColor': '#000000', 'color':'#000000', 'fillOpacity': 0.50, 'weight': 0.1}

tooltip = folium.features.GeoJsonTooltip(
    fields=['District Name (English)', 'District Name (Chinese)', 'Population Density'],
    aliases=['District: ', '地区: ', 'Density: '],
    localize=True,
    sticky=True,
    labels=True,
    style="""
        background-color: #F0EFEF;
        border: 1px solid black;
        border-radius: 3px;
        box-shadow: 3px 3px rgba(0, 0, 0, 0.25);
        font-size: 12px;
    """,
    max_width=800
)

folium.GeoJson(
    geo_data,
    style_function=style_function,
    highlight_function=highlight_function,
    tooltip=tooltip
).add_to(hong_kong_map)

# Display the map
hong_kong_map.save('hong_kong_population_density_with_names.html')
hong_kong_map

import matplotlib.pyplot as plt
import seaborn as sns

# Sort data by population density
sorted_df = df.sort_values(by='Population Density', ascending=False)

# Create a bar plot for population density
plt.figure(figsize=(12, 6))
sns.barplot(
    x='District Name (English)',
    y='Population Density',
    data=sorted_df,
    palette='Blues_d'
)
plt.xticks(rotation=90)
plt.title('Population Density by District (2022)')
plt.xlabel('District')
plt.ylabel('Population Density (people/km²)')
plt.show()

import seaborn as sns

# Compute correlation matrix
correlation_matrix = df[['Area (km²)', 'Population (thousands)', 'Population Density']].corr()

# Create heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Correlation Matrix')
plt.show()

# Calculate population percentage
df['Population Percentage'] = (df['Population (thousands)'] / df['Population (thousands)'].sum()) * 100

# Plot pie chart
plt.figure(figsize=(8, 8))
plt.pie(
    df['Population Percentage'],
    labels=df['District Name (English)'],
    autopct='%1.1f%%',
    startangle=140,
    colors=sns.color_palette('pastel')
)
plt.title('Population Distribution by District')
plt.show()

import plotly.express as px

# Create scatter plot
fig = px.scatter(
    df,
    x='Area (km²)',
    y='Population Density',
    size='Population (thousands)',
    color='District Name (English)',
    title='Population Density vs Area',
    labels={'Area (km²)': 'Area (km²)', 'Population Density': 'Population Density (people/km²)'}
)
fig.show()

df = df.copy()
df_density = df[['District Name (English)', 'Population Density']]
df_density.rename(columns={'District Name (English)': 'District Council district (DCD)'}, inplace=True)

df_density

"""# **2. Elder**"""

df = pd.read_excel("elder_normalization.xlsx")

df

display_df = df.copy()
display_df['No.'] = display_df['No.'].map('{:.1f}'.format)
display_df['Percentage(%)'] = display_df['Percentage(%)'].map('{:,}'.format)

styled_df = display_df.style \
    .set_caption("Elder Data by District") \
    .set_properties(**{'text-align': 'center'}) \
    .background_gradient(cmap='Blues',
                        subset=['Percentage(%)'],
                        vmin=df['Percentage(%)'].min(),
                        vmax=df['Percentage(%)'].max()
    )

styled_df

average_elderly_data = df.groupby('District Council district (DCD)').agg({
    'Percentage(%)': 'mean',
    'No.': 'mean'
}).reset_index()



average_elderly_data.rename(columns={
    'Percentage(%)': 'Average Elderly Percentage (%)',
    'No.': 'Average Elderly Population (thousands)'
}, inplace=True)

print(average_elderly_data)

df_average_elderly_percentage = average_elderly_data[['District Council district (DCD)', 'Average Elderly Percentage (%)']]

df_average_elderly_percentage

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(12, 6))
sns.barplot(
    x='District Council district (DCD)',
    y='Average Elderly Percentage (%)',
    data=average_elderly_data,
    palette='Blues_d'
)

plt.title('Average Elderly Percentage by District (2020-2024)', fontsize=16)
plt.xlabel('District', fontsize=12)
plt.ylabel('Average Elderly Percentage (%)', fontsize=12)
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

plt.figure(figsize=(12, 6))
sns.barplot(
    x='District Council district (DCD)',
    y='Average Elderly Population (thousands)',
    data=average_elderly_data,
    palette='Greens_d'
)

plt.title('Average Elderly Population by District (2020-2024)', fontsize=16)
plt.xlabel('District', fontsize=12)
plt.ylabel('Average Elderly Population (thousands)', fontsize=12)
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

fig, ax1 = plt.subplots(figsize=(12, 6))

sns.barplot(
    x='District Council district (DCD)',
    y='Average Elderly Percentage (%)',
    data=average_elderly_data,
    palette='Blues_d',
    ax=ax1
)
ax1.set_ylabel('Average Elderly Percentage (%)', fontsize=12)
ax1.set_xlabel('District', fontsize=12)
ax1.tick_params(axis='y', labelcolor='blue')
ax1.set_xticklabels(average_elderly_data['District Council district (DCD)'], rotation=90)

ax2 = ax1.twinx()
sns.lineplot(
    x='District Council district (DCD)',
    y='Average Elderly Population (thousands)',
    data=average_elderly_data,
    color='green',
    marker='o',
    ax=ax2
)
ax2.set_ylabel('Average Elderly Population (thousands)', fontsize=12)
ax2.tick_params(axis='y', labelcolor='green')

plt.title('Comparison of Elderly Percentage and Population by District (2020-2024)', fontsize=16)
plt.tight_layout()
plt.show()

# geo_data = geo_data.merge(
#     df,
#     left_on='DC_ENG',
#     right_on='District Council district (DCD)',
# )
# print(geo_data.head())

# import folium

# # Create a base map centered on Hong Kong
# hong_kong_map = folium.Map(location=[22.3193, 114.1694], zoom_start=11, tiles='CartoDB positron')

# # Add choropleth layer for elder percentage
# folium.Choropleth(
#     geo_data=geo_data,
#     data=geo_data,
#     columns=['DC_ENG', 'Percentage(%)'],
#     key_on='feature.properties.DC_ENG',
#     fill_color='YlOrRd',
#     fill_opacity=0.5,
#     line_opacity=0.4,
#     line_weight=0.9,
#     legend_name='Elderly Population Percentage (%)',
#     bins=6,
#     smooth_factor=0.3
# ).add_to(hong_kong_map)

# # Add district labels
# for _, row in geo_data.iterrows():
#     if row['geometry'].is_empty or row['geometry'].centroid.is_empty:
#         continue

#     centroid = row['geometry'].centroid
#     folium.Marker(
#         location=[centroid.y, centroid.x],
#         popup=f"""
#         <div style="font-weight:bold">{row['DC_ENG']}</div>
#         <div>Elderly: {row['Percentage(%)']}%</div>
#         """,
#         icon=folium.DivIcon(
#             html=f"""
#             <div style="
#                 font-size: 10pt;
#                 font-weight: bold;
#                 color: #333;
#                 text-shadow:
#                     -1px -1px 0 #fff,
#                     1px -1px 0 #fff,
#                     -1px 1px 0 #fff,
#                     1px 1px 0 #fff;
#                 ">
#                 {row['DC_ENG']}
#             </div>
#             """
#         )
#     ).add_to(hong_kong_map)

# style_function = lambda x: {
#     'fillColor': '#ffffff',
#     'color': '#000000',
#     'fillOpacity': 0.1,
#     'weight': 0.1
# }

# highlight_function = lambda x: {
#     'fillColor': '#ff0000',
#     'color': '#000000',
#     'fillOpacity': 0.7,
#     'weight': 1.5
# }

# tooltip = folium.features.GeoJsonTooltip(
#     fields=['DC_ENG', 'Percentage(%)'],
#     aliases=['<b>District</b>: ', '<b>Elderly %</b>: '],
#     localize=True,
#     sticky=True,
#     labels=True,
#     style="""
#         background-color: #FFFFFF;
#         border: 2px solid #FF6B6B;
#         border-radius: 5px;
#         box-shadow: 5px 5px rgba(0, 0, 0, 0.1);
#         font-size: 14px;
#         padding: 10px;
#     """,
#     max_width=800
# )

# # Add GeoJSON layer with enhanced styling
# folium.GeoJson(
#     geo_data,
#     style_function=style_function,
#     control=False,
#     highlight_function=highlight_function,
#     tooltip=tooltip
# ).add_to(hong_kong_map)

# folium.LayerControl().add_to(hong_kong_map)

# # Save the map
# hong_kong_map.save('hong_kong_elderly_population.html')
# hong_kong_map

"""# **3. Median Income**"""







import pandas as pd
import numpy as np

# Define the years and districts
years = [2020, 2021, 2022, 2023, 2024]
districts = [
    '中西区', '湾仔区', '东区', '南区', '油尖旺区', '深水埗区',
    '九龙城区', '黄大仙区', '观塘区', '葵青区', '荃湾区', '屯门区',
    '元朗区', '北区', '大埔区', '沙田区', '西贡区', '离岛区'
]

# English names for output (without DCD suffix)
district_english = [
    'Central and Western', 'Wan Chai', 'Eastern', 'Southern',
    'Yau Tsim Mong', 'Sham Shui Po', 'Kowloon City', 'Wong Tai Sin',
    'Kwun Tong', 'Kwai Tsing', 'Tsuen Wan', 'Tuen Mun',
    'Yuen Long', 'North', 'Tai Po', 'Sha Tin', 'Sai Kung', 'Islands'
]

# Create a dictionary to map Chinese to English names
district_map = dict(zip(districts, district_english))
# Your provided data (2020-2024 median incomes)
district_incomes = {
    'Wong Tai Sin': [24300, 23300, 24400, 25100, 25600],
    'Sha Tin': [28400, 27100, 29700, 30500, 31000],
    'Tai Po': [29500, 30000, 30200, 31700, 31300],
    'Tuen Mun': [24700, 25400, 25800, 26500, 26200],
    'Kwai Tsing': [24300, 23300, 24300, 26000, 25500],
    'Central and Western': [41200, 42000, 42300, 42600, 42400],
    'Yuen Long': [25000, 27000, 28900, 30100, 30000],
    'Islands': [26100, 28800, 29400, 31500, 31000],
    'Tsuen Wan': [30000, 31800, 32300, 34400, 34200],
    'Wan Chai': [40000, 40400, 41800, 40500, 40800],
    'Kowloon City': [30000, 29700, 30000, 30700, 31100],
    'Sai Kung': [35600, 37200, 40000, 40400, 41200],
    'Eastern': [32200, 31500, 31500, 33800, 32500],
    'Sham Shui Po': [23500, 22000, 22800, 24100, 24500],
    'North': [25000, 23300, 24400, 25500, 25800],
    'Kwun Tong': [22000, 22200, 22100, 24000, 24200],
    'Southern': [32100, 33000, 34200, 36000, 36000],
    'Yau Tsim Mong': [28000, 27900, 29000, 30700, 29000]
}

# Calculate 5-year median for each district
median_5year = {district: round(sum(incomes)/5, 2) for district, incomes in district_incomes.items()}

# Create DataFrame and sort by median income
df = pd.DataFrame(list(median_5year.items()), columns=['District', 'Median Income'])
df = df.sort_values('Median Income', ascending=False).reset_index(drop=True)

# Print results in requested format
print("## Median Household Income by District Council District (2020-2024)")
print("District Council district (DCD)  Median Income (2020-2024) (HK$)\n")

# Print header with right-aligned numbers
print(f"{'':<4}{'District Council district (DCD)':<25} {'Median Income':>20}")

# Print each row with right-aligned numbers
for index, row in df.iterrows():
    print(f"{index:<4}{row['District']:<25} {row['Median Income']:>20.2f}")

df_median_income = df.rename(columns={
    'District': 'District Council district (DCD)',
    'Median Income': 'Average Median Income'
})


df_median_income

"""# **Clustering**"""

combined_data = df_density.merge(df_average_elderly_percentage, on='District Council district (DCD)')
combined_data = combined_data.merge(df_median_income, on='District Council district (DCD)')

combined_data

from sklearn.preprocessing import MinMaxScaler
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import seaborn as sns

# 假设 combined_data 包含以下列：
# 'District Council district (DCD)', 'Population Density', 'Average Elderly Percentage (%)', 'Median Income (2020-2024) (HK$)'

# 选择需要标准化的列
columns_to_normalize = ['Population Density', 'Average Elderly Percentage (%)', 'Average Median Income']

# 标准化数据
scaler = MinMaxScaler()
combined_data[columns_to_normalize] = scaler.fit_transform(combined_data[columns_to_normalize])

# 使用 K-Means 聚类
kmeans = KMeans(n_clusters=3, random_state=42)
combined_data['Cluster'] = kmeans.fit_predict(combined_data[columns_to_normalize])

# 查看聚类结果
combined_data

# 检查列的数据类型
print(combined_data[columns_to_normalize].dtypes)

# 如果有非数值列，尝试转换
for col in columns_to_normalize:
    combined_data[col] = pd.to_numeric(combined_data[col], errors='coerce')

import matplotlib.pyplot as plt

# 按聚类分组，计算特征均值
cluster_profiles = combined_data.groupby('Cluster')[columns_to_normalize].mean()

# 检查是否有数据
if cluster_profiles.empty:
    print("No data available for plotting.")
else:
    # 绘制柱状图
    cluster_profiles.plot(kind='bar', figsize=(10, 6), colormap='viridis')
    plt.title('Cluster Profiles')
    plt.ylabel('Normalized Values')
    plt.xlabel('Cluster')
    plt.xticks(rotation=0)
    plt.legend(loc='upper right')
    plt.tight_layout()
    plt.show()

cluster_profiles

import seaborn as sns

sns.scatterplot(
    x='Population Density',
    y='Average Elderly Percentage (%)',
    hue='Cluster',
    data=combined_data,
    palette='Set2'
)
plt.title('Clustering of Districts')
plt.xlabel('Population Density')
plt.ylabel('Average Elderly Percentage (%)')
plt.legend(title='Cluster')
plt.show()

sns.scatterplot(
    x='Population Density',
    y='Average Median Income',
    hue='Cluster',
    data=combined_data,
    palette='Set2'
)
plt.title('Clustering of Districts')
plt.xlabel('Population Density')
plt.ylabel('Average Median Income')
plt.legend(title='Cluster')
plt.show()

sns.scatterplot(
    x='Average Elderly Percentage (%)',
    y='Average Median Income',
    hue='Cluster',
    data=combined_data,
    palette='Set2'
)
plt.title('Clustering of Districts')
plt.xlabel('Average Elderly Percentage (%)')
plt.ylabel('Average Median Income')
plt.legend(title='Cluster')
plt.show()

import plotly.express as px

# 使用 Plotly 绘制 3D 散点图
fig = px.scatter_3d(
    combined_data,
    x='Population Density',
    y='Average Elderly Percentage (%)',
    z='Average Median Income',
    color='Cluster',  # 使用分类变量
    color_discrete_sequence=px.colors.qualitative.Set2,  # 使用离散调色板 Set2
    symbol='Cluster',  # 不同聚类使用不同的符号
    size_max=10,  # 点的最大大小
    title='3D Clustering of Districts'
)

# 设置轴标签
fig.update_layout(
    scene=dict(
        xaxis_title='Population Density',
        yaxis_title='Average Elderly Percentage (%)',
        zaxis_title='Average Median Income'
    )
)

# 显示图形
fig.show()

import numpy as np

# 绘制雷达图
def plot_radar(data, labels, title):
    angles = np.linspace(0, 2 * np.pi, len(labels), endpoint=False).tolist()
    data = np.concatenate((data, [data[0]]))  # 闭合雷达图
    angles += angles[:1]

    fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(polar=True))
    ax.fill(angles, data, color='blue', alpha=0.25)
    ax.plot(angles, data, color='blue', linewidth=2)
    ax.set_yticks([])
    ax.set_xticks(angles[:-1])
    ax.set_xticklabels(labels)
    ax.set_title(title, size=15, y=1.1)
    plt.show()

# 示例：绘制第一个聚类的雷达图
labels = columns_to_normalize
plot_radar(cluster_profiles.iloc[0].values, labels, 'Cluster 0 Profile')
print("__________")
print("          ")
plot_radar(cluster_profiles.iloc[1].values, labels, 'Cluster 1 Profile')
print("__________")
print("          ")
plot_radar(cluster_profiles.iloc[2].values, labels, 'Cluster 2 Profile')